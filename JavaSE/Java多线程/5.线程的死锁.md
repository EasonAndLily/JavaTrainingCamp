# 多线程的死锁

![single_plank_bridge](https://tva1.sinaimg.cn/large/008eGmZEly1gnkw9daxnnj30go0cugmc.jpg)

上面的图片描述了这样一幅场景，两个壮汉要过一座独木桥，他们从两头都走到了独木桥的中间，各自都不相让，于是在桥中间争吵了起来，结果谁也过不了河，最终耗死在这座独木桥上！这种看似简单的生活场景在多线程中比较普遍，我们称之为死锁。

## 死锁的产生

**所谓死锁，是指两个或者两个以上的线程在执行任务的过程中，争夺对方所持有的资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。**

两个壮汉好比两个线程，他们为了争夺对方已经走过的那段独木桥(资源)而互相等待，各自都不想让，产生了死锁。

我们使用火车站售票的情形来模拟一种死锁：火车站可以出售两种类型的车票：成人票和儿童票。对成人票来说，只需要成人拿着身份证就可以在售票窗口售票，之后等待打印机打印出车票即可。对于儿童票来说，先要去使用打印机打印儿童证明之后，去购票窗口盖章，凭借盖章后儿童证明即可上车。任何情况下，售票窗口或者打印机只能允许一位乘客进行操作。

代码实现如下：

1.首先定一个车票类型的枚举类：普通车票和儿童票

```java
public enum TicketsType {
    NORMAL, CHILDREN
}
```

2.定义出售车票的线程类：使用`sleep()`方面模拟售票过程

```java
public class SaleTickets implements Runnable {
    private static Object lockSalesWindow = new Object();
    private static Object lockPrinter = new Object();
    private TicketsType ticketsType;

    public SaleTickets(TicketsType ticketsType) {
        this.ticketsType = ticketsType;
    }

    @Override
    public void run() {
        try {
            switch (this.ticketsType) {
                case NORMAL:
                    synchronized (lockSalesWindow) {
                        System.out.println("出售一张成人车票。。。");
                        Thread.currentThread().sleep(1000);
                        synchronized (lockPrinter) {
                            System.out.println("打印一张成人车票。。。");
                            Thread.currentThread().sleep(1000);
                        }
                        break;
                    }
                case CHILDREN:
                    synchronized (lockPrinter) {
                        System.out.println("打印儿童证明。。。");
                        Thread.currentThread().sleep(1000);
                        synchronized (lockSalesWindow) {
                            System.out.println("已经为儿童车票盖章。。。");
                            Thread.currentThread().sleep(1000);
                            break;
                        }
                    }
                default:
                    System.out.println("不支持此车票类型，无法出售！");
                    break;
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

3.定义线程启动类：

```java
public class Main {
    public static void main(String[] args) {
        SaleTickets saleNomalTickets = new SaleTickets(TicketsType.NORMAL);
        SaleTickets saleChildrenTickets = new SaleTickets(TicketsType.CHILDREN);
        Thread salesNormal = new Thread(saleNomalTickets);
        Thread salesChildren = new Thread(saleChildrenTickets);
        salesChildren.start();
        salesNormal.start();
    }
}
```

运行结果如下：

```bash
打印儿童证明。。。
出售一张成人车票。。。
```

从上面的运行结果看出，除非手动结束，否则将永远等待下去，无法为任何人出售一张车票，这就产生了死锁。

上面的死锁非常经典，出售成人车票时，必须要获得两个必要资源(售票窗口和打印机)，出售儿童车票的时候，也需要这两个资源。但是这两个资源的使用顺序不一致，但出售成人车票的线程占用售票窗口的同时需要请求打印机资源，而出售儿童车票的窗口在占用打印机资源的同时需要请求占用售票窗口，这样两个线程互相等待对方持有的资源而无限等待下去，导致死锁。

### 死锁产生的原因

1. **系统资源的竞争**

通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争 才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。

2. **进程推进顺序非法**

进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。上面的火车站售票的例子就是如此。

信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A 发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。

### 死锁发生的必要条件

只有当多个线程同时满足如下的四个条件时，才有可能发生死锁。

1. **互斥条件：** 一个资源每次只能被一个进程使用。独木桥每次只能通过一个人。
2. **请求与保持条件：** 一个进程因请求资源而阻塞时，对已获得的资源保持不放。乙不退出桥面，甲也不退出桥面。
3. **不剥夺条件:** 进程已获得的资源，在未使用完之前，不能强行剥夺。甲不能强制乙退出桥面，乙也不能强制甲退出桥面。
4. **循环等待条件：** 若干进程之间形成一种头尾相接的循环等待资源关系。完成线程A需要等待线程B释放资源，完成线程B需要等待线程C释放资源，完成线程C需要等待线程A释放资源，如此形成了一个收尾相接的循环等待资源的关系。


