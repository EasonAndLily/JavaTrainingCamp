# Collection之Queue

![queue](https://tva1.sinaimg.cn/large/008eGmZEly1gnxtb5fyx4j30rs08iacu.jpg)

类似于超市购物需要排队一样，Queue(队列)也是一种数据结构，是一种先进先出（FIFO：First In First Out）的线性表，即它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

## [Queue接口](https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html)

Queue接口直接继承了Collection接口，Queue除了具有集合本身的操作方法，还提供了额外的方法用于Queue的增删改操作，不同的是，前者在特殊情况下会抛出异常，后者不会，所以，除非有特殊情况，否则我们推荐使用后者。		
| 方法描述 | throw Exception| 返回false或null|
|---------|----------------|---------------|
| 添加元素到队尾 | add(E e) | boolean offer(E e)|
| 取队首元素并删除 | E remove() | E poll() |
| 取队首元素但不删除 | E element()|E peek() |

作为Queue的顶层接口，其实现类自然是有不少，下面是比较常见的几种实现类：

![queue-sub-classes](https://tva1.sinaimg.cn/large/008eGmZEly1gnyzppqnwkj31th0lb77a.jpg)

### [AbstractQueue](https://docs.oracle.com/javase/8/docs/api/java/util/AbstractQueue.html)

AbstractQueue是Java提供的最简单的队列实现。它包括某些Queue接口方法的基本实现，但`offer()`除外。当我们创建扩展AbstractQueue类的自定义队列时，必须提供offer方法的实现，该方法不允许插入空元素。此外，我们必须提供peek，poll，size和java.util的迭代器方法。

#### [PriorityQueue](https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html)

现实生活中，当你去医院做检查的时候，普通门诊的病人会按照顺序依次检查，但是如果遇到急诊的病人，就需要优先检查。这个时候，我们很难使用`Queue`来实现插队业务，因为`Queue`会严格按FIFO的原则取出队首元素

优先队列`PriorityQueue`可以解决这个问题，`PriorityQueue`和`Queue`的区别在于，它的出队顺序与元素的优先级有关，对`PriorityQueue`调用`remove()`或`poll()`方法，返回的总是优先级最高的元素。

要使用`PriorityQueue`，我们就必须给每个元素定义“优先级”。放入`PriorityQueue`的元素，必须实现`Comparable`接口，`PriorityQueue`会根据元素的排序顺序决定出队的优先级。如果没有实现该接口或者定义比较器，那么元素将会用自然排序。

例如：
```java
PriorityQueue<String> stringQueue = new PriorityQueue<>();

stringQueue.add("blueberry");
stringQueue.add("apple");
stringQueue.add("cherry");

String first = stringQueue.poll();
String second = stringQueue.poll();
String third = stringQueue.poll();

assertEquals("apple", first);
assertEquals("blueberry", second);
assertEquals("cherry", third);
```

### [Blocking Queues](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html)

BlockingQueue接口支持其他操作，这些操作强制线程根据当前状态等待Queue。尝试进行检索时，线程可能会等待Queue为非空，或者在添加新元素时可能变为空。

Standard Blocking Queues include LinkedBlockingQueue, SynchronousQueue, and ArrayBlockingQueue.

想了解更详细的信息，请参考这里[Blocking Queues](https://www.baeldung.com/java-blocking-queue)

#### [Transfer Queues](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TransferQueue.html)

TransferQueue接口扩展了BlockingQueue接口，但针对生产者-消费者模式进行了定制。它控制从生产者到消费者的信息流，从而在系统中产生背压。

## [Deque](https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html)

Queue只允许在队尾插入，队首删除。实际使用过程中，你可能需要在队首插入，队尾删除的队列，或者需要两端都可以进行删除的插入的队列，这该怎么办呢？

那么，双端队列`Deque`可以解决你的问题。允许两头都进，两头都出，这种队列叫双端队列（Double Ended Queue）。

我们来比较一下`Queue`和`Deque`出队和入队的方法：
| 方法描述 | Queue | Deque |
|---------|----------------|---------------|
| 添加元素到队尾 | add(E e) / offer(E e) | addLast(E e) / offerLast(E e)|
| 取队首元素并删除 | E remove() / E poll() | E removeFirst() / E pollFirst() |
| 取队首元素但不删除 | E element() / E peek()| E getFirst() / E peekFirst() |
|添加元素到队首|	无|	addFirst(E e) / offerFirst(E e)|
|取队尾元素并删除|	无|	E removeLast() / E pollLast()|
|取队尾元素但不删除|	无|	E getLast() / E peekLast()|

因此，`Queue`提供的`add()/offer()`方法在`Deque`中也可以使用，但是，使用`Deque`，最好不要调用`offer()`，而是调用`offerLast()`。




